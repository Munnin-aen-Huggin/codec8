-- ============================================
-- SECURITY PEN TEST FIXES V2 - 2026-01-16
-- Fixes all linter warnings - handles partial previous run
-- ============================================

-- ============================================
-- 1. FIX FUNCTION SEARCH_PATH VULNERABILITIES
-- ============================================

-- Drop functions that need return type changes
DROP FUNCTION IF EXISTS public.get_team_usage(UUID);
DROP FUNCTION IF EXISTS public.get_sso_config_by_identifier(TEXT);

-- 1.1 Fix create_team_owner_membership
CREATE OR REPLACE FUNCTION public.create_team_owner_membership()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
BEGIN
  INSERT INTO public.team_members (team_id, user_id, role, status, joined_at)
  VALUES (NEW.id, NEW.owner_id, 'owner', 'active', NOW())
  ON CONFLICT (team_id, user_id) DO NOTHING;
  RETURN NEW;
END;
$$;

-- 1.2 Fix is_team_member
CREATE OR REPLACE FUNCTION public.is_team_member(team_uuid UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.team_members
    WHERE team_id = team_uuid
    AND user_id = auth.uid()
    AND status = 'active'
  );
END;
$$;

-- 1.3 Fix is_team_admin
CREATE OR REPLACE FUNCTION public.is_team_admin(team_uuid UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.team_members
    WHERE team_id = team_uuid
    AND user_id = auth.uid()
    AND role IN ('owner', 'admin')
    AND status = 'active'
  );
END;
$$;

-- 1.4 Fix get_team_usage
CREATE OR REPLACE FUNCTION public.get_team_usage(team_uuid UUID)
RETURNS TABLE (
  total_docs BIGINT,
  total_repos BIGINT,
  member_count BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
BEGIN
  IF NOT public.is_team_member(team_uuid) THEN
    RAISE EXCEPTION 'Access denied: not a team member';
  END IF;

  RETURN QUERY
  SELECT
    (SELECT COUNT(*) FROM public.documentation d
     JOIN public.repositories r ON d.repo_id = r.id
     WHERE r.team_id = team_uuid)::BIGINT as total_docs,
    (SELECT COUNT(*) FROM public.repositories WHERE team_id = team_uuid)::BIGINT as total_repos,
    (SELECT COUNT(*) FROM public.team_members WHERE team_id = team_uuid AND status = 'active')::BIGINT as member_count;
END;
$$;

-- 1.5 Fix get_sso_config_by_identifier
CREATE OR REPLACE FUNCTION public.get_sso_config_by_identifier(identifier TEXT)
RETURNS TABLE (
  id UUID,
  team_id UUID,
  provider TEXT,
  domain TEXT,
  metadata_url TEXT,
  entity_id TEXT,
  sso_url TEXT,
  certificate TEXT,
  enabled BOOLEAN
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
BEGIN
  RETURN QUERY
  SELECT
    sc.id,
    sc.team_id,
    sc.provider,
    sc.domain,
    sc.metadata_url,
    sc.entity_id,
    sc.sso_url,
    sc.certificate,
    sc.enabled
  FROM public.sso_configs sc
  WHERE sc.domain = identifier
     OR sc.entity_id = identifier
     OR sc.id::TEXT = identifier;
END;
$$;

-- 1.6 Fix cleanup_expired_sso_sessions
CREATE OR REPLACE FUNCTION public.cleanup_expired_sso_sessions()
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM public.sso_sessions
  WHERE expires_at < NOW()
  RETURNING 1 INTO deleted_count;

  RETURN COALESCE(deleted_count, 0);
END;
$$;

-- ============================================
-- 2. FIX PROFILES TABLE RLS
-- ============================================
DROP POLICY IF EXISTS "profiles_allow_all" ON public.profiles;
DROP POLICY IF EXISTS "Users can view own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can update own profile" ON public.profiles;

CREATE POLICY "Users can view own profile"
ON public.profiles FOR SELECT
USING (id = auth.uid());

CREATE POLICY "Users can update own profile"
ON public.profiles FOR UPDATE
USING (id = auth.uid())
WITH CHECK (id = auth.uid());

-- ============================================
-- 3. FIX REPOSITORIES TABLE RLS
-- ============================================
DROP POLICY IF EXISTS "repositories_allow_all" ON public.repositories;
DROP POLICY IF EXISTS "Users can view own repositories" ON public.repositories;
DROP POLICY IF EXISTS "Users can insert own repositories" ON public.repositories;
DROP POLICY IF EXISTS "Users can update own repositories" ON public.repositories;
DROP POLICY IF EXISTS "Users can delete own repositories" ON public.repositories;

CREATE POLICY "Users can view own repositories"
ON public.repositories FOR SELECT
USING (
  user_id = auth.uid()
  OR team_id IN (
    SELECT tm.team_id FROM public.team_members tm
    WHERE tm.user_id = auth.uid() AND tm.status = 'active'
  )
);

CREATE POLICY "Users can insert own repositories"
ON public.repositories FOR INSERT
WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own repositories"
ON public.repositories FOR UPDATE
USING (
  user_id = auth.uid()
  OR team_id IN (
    SELECT tm.team_id FROM public.team_members tm
    WHERE tm.user_id = auth.uid() AND tm.role IN ('owner', 'admin') AND tm.status = 'active'
  )
)
WITH CHECK (
  user_id = auth.uid()
  OR team_id IN (
    SELECT tm.team_id FROM public.team_members tm
    WHERE tm.user_id = auth.uid() AND tm.role IN ('owner', 'admin') AND tm.status = 'active'
  )
);

CREATE POLICY "Users can delete own repositories"
ON public.repositories FOR DELETE
USING (
  user_id = auth.uid()
  OR team_id IN (
    SELECT tm.team_id FROM public.team_members tm
    WHERE tm.user_id = auth.uid() AND tm.role IN ('owner', 'admin') AND tm.status = 'active'
  )
);

-- ============================================
-- 4. FIX DOCUMENTATION TABLE RLS
-- ============================================
DROP POLICY IF EXISTS "documentation_allow_all" ON public.documentation;
DROP POLICY IF EXISTS "Users can view documentation" ON public.documentation;
DROP POLICY IF EXISTS "Users can insert documentation" ON public.documentation;
DROP POLICY IF EXISTS "Users can update documentation" ON public.documentation;
DROP POLICY IF EXISTS "Users can delete documentation" ON public.documentation;

CREATE POLICY "Users can view documentation"
ON public.documentation FOR SELECT
USING (
  repo_id IN (
    SELECT r.id FROM public.repositories r
    WHERE r.user_id = auth.uid()
    OR r.team_id IN (
      SELECT tm.team_id FROM public.team_members tm
      WHERE tm.user_id = auth.uid() AND tm.status = 'active'
    )
  )
);

CREATE POLICY "Users can insert documentation"
ON public.documentation FOR INSERT
WITH CHECK (
  repo_id IN (
    SELECT r.id FROM public.repositories r
    WHERE r.user_id = auth.uid()
    OR r.team_id IN (
      SELECT tm.team_id FROM public.team_members tm
      WHERE tm.user_id = auth.uid() AND tm.status = 'active'
    )
  )
);

CREATE POLICY "Users can update documentation"
ON public.documentation FOR UPDATE
USING (
  repo_id IN (
    SELECT r.id FROM public.repositories r
    WHERE r.user_id = auth.uid()
    OR r.team_id IN (
      SELECT tm.team_id FROM public.team_members tm
      WHERE tm.user_id = auth.uid() AND tm.status = 'active'
    )
  )
)
WITH CHECK (
  repo_id IN (
    SELECT r.id FROM public.repositories r
    WHERE r.user_id = auth.uid()
    OR r.team_id IN (
      SELECT tm.team_id FROM public.team_members tm
      WHERE tm.user_id = auth.uid() AND tm.status = 'active'
    )
  )
);

CREATE POLICY "Users can delete documentation"
ON public.documentation FOR DELETE
USING (
  repo_id IN (
    SELECT r.id FROM public.repositories r
    WHERE r.user_id = auth.uid()
    OR r.team_id IN (
      SELECT tm.team_id FROM public.team_members tm
      WHERE tm.user_id = auth.uid() AND tm.role IN ('owner', 'admin') AND tm.status = 'active'
    )
  )
);

-- ============================================
-- 5. FIX LICENSES TABLE RLS
-- ============================================
DROP POLICY IF EXISTS "licenses_allow_all" ON public.licenses;
DROP POLICY IF EXISTS "Users can view own licenses" ON public.licenses;

CREATE POLICY "Users can view own licenses"
ON public.licenses FOR SELECT
USING (user_id = auth.uid());

-- ============================================
-- 6. FIX EMAIL_SIGNUPS TABLE RLS
-- ============================================
DROP POLICY IF EXISTS "email_signups_allow_all" ON public.email_signups;
DROP POLICY IF EXISTS "Anyone can insert email signups" ON public.email_signups;
DROP POLICY IF EXISTS "service_role_all_email_signups" ON public.email_signups;

CREATE POLICY "Anyone can insert email signups"
ON public.email_signups FOR INSERT
WITH CHECK (true);

CREATE POLICY "service_role_all_email_signups" ON public.email_signups
  FOR ALL
  TO service_role
  USING (true)
  WITH CHECK (true);

-- ============================================
-- 7. FIX ANALYTICS_EVENTS TABLE RLS
-- ============================================
DROP POLICY IF EXISTS "Allow anonymous analytics inserts" ON public.analytics_events;
DROP POLICY IF EXISTS "anon_insert_analytics_events" ON public.analytics_events;
DROP POLICY IF EXISTS "authenticated_insert_analytics_events" ON public.analytics_events;
DROP POLICY IF EXISTS "Insert analytics events with validation" ON public.analytics_events;
DROP POLICY IF EXISTS "service_role_all_analytics_events" ON public.analytics_events;

CREATE POLICY "Insert analytics events with validation"
ON public.analytics_events FOR INSERT
WITH CHECK (
  event_name IS NOT NULL
  AND LENGTH(event_name) <= 100
  AND (event_data IS NULL OR LENGTH(event_data::TEXT) <= 10000)
);

CREATE POLICY "service_role_all_analytics_events" ON public.analytics_events
  FOR ALL
  TO service_role
  USING (true)
  WITH CHECK (true);

-- ============================================
-- 8. FIX LEADS TABLE RLS
-- ============================================
DROP POLICY IF EXISTS "Allow anonymous lead inserts" ON public.leads;
DROP POLICY IF EXISTS "anon_insert_leads" ON public.leads;
DROP POLICY IF EXISTS "anon_update_leads" ON public.leads;
DROP POLICY IF EXISTS "authenticated_insert_leads" ON public.leads;
DROP POLICY IF EXISTS "Insert leads with validation" ON public.leads;
DROP POLICY IF EXISTS "service_role_all_leads" ON public.leads;

CREATE POLICY "Insert leads with validation"
ON public.leads FOR INSERT
WITH CHECK (
  email IS NOT NULL
  AND LENGTH(email) <= 255
  AND email ~ '^[^@]+@[^@]+\.[^@]+$'
  AND (source IS NULL OR LENGTH(source) <= 100)
);

CREATE POLICY "service_role_all_leads" ON public.leads
  FOR ALL
  TO service_role
  USING (true)
  WITH CHECK (true);

-- ============================================
-- 9. ADD RATE LIMITING SUPPORT COLUMNS
-- ============================================
ALTER TABLE public.leads
ADD COLUMN IF NOT EXISTS created_ip INET,
ADD COLUMN IF NOT EXISTS fingerprint TEXT;

CREATE INDEX IF NOT EXISTS idx_leads_created_ip ON public.leads(created_ip);
CREATE INDEX IF NOT EXISTS idx_leads_fingerprint ON public.leads(fingerprint);
CREATE INDEX IF NOT EXISTS idx_leads_created_at ON public.leads(created_at);

ALTER TABLE public.email_signups
ADD COLUMN IF NOT EXISTS created_ip INET,
ADD COLUMN IF NOT EXISTS fingerprint TEXT;

CREATE INDEX IF NOT EXISTS idx_email_signups_created_ip ON public.email_signups(created_ip);
CREATE INDEX IF NOT EXISTS idx_email_signups_fingerprint ON public.email_signups(fingerprint);

-- ============================================
-- 10. VERIFICATION
-- ============================================
DO $$
DECLARE
  policy_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO policy_count
  FROM pg_policies
  WHERE policyname IN (
    'profiles_allow_all',
    'repositories_allow_all',
    'documentation_allow_all',
    'licenses_allow_all',
    'email_signups_allow_all',
    'anon_update_leads',
    'Allow anonymous analytics inserts',
    'anon_insert_analytics_events',
    'authenticated_insert_analytics_events',
    'Allow anonymous lead inserts',
    'anon_insert_leads',
    'authenticated_insert_leads'
  );

  IF policy_count = 0 THEN
    RAISE NOTICE 'SUCCESS: All dangerous policies removed';
  ELSE
    RAISE WARNING 'WARNING: % dangerous policies still exist', policy_count;
  END IF;
END $$;
