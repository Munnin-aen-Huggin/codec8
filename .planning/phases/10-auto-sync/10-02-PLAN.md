---
phase: 10-auto-sync
plan: 02
type: execute
---

<objective>
Implement GitHub webhook receiver and automatic documentation regeneration.

Purpose: Process push events from GitHub and trigger doc regeneration automatically.
Output: Working auto-sync feature that regenerates docs when users push to their repos.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-auto-sync/10-01-SUMMARY.md (after Plan 01 completes)
@src/lib/server/github.ts
@src/routes/api/docs/generate/+server.ts (existing doc generation logic)
@src/routes/api/stripe/webhook/+server.ts (pattern reference)

**Tech stack available:** SvelteKit 2.0, Supabase PostgreSQL, GitHub API, Claude API
**Established patterns:** Webhook signature verification (Stripe pattern), doc generation flow

**From Plan 01:**
- repositories table has webhook_secret column
- GitHub webhook functions exist
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GitHub webhook receiver endpoint</name>
  <files>src/routes/api/github/webhook/+server.ts</files>
  <action>
    Create endpoint to receive GitHub push webhooks:

    POST handler:
    1. Extract headers: X-GitHub-Event, X-Hub-Signature-256, X-GitHub-Delivery
    2. Parse request body as text first (for signature verification)
    3. Extract repository full_name from payload to find matching repo in database
    4. Look up webhook_secret from repositories table where full_name matches
    5. Verify HMAC-SHA256 signature using webhook_secret
    6. Only process 'push' events (ignore ping, etc.)
    7. If valid push event, queue regeneration (Task 2)
    8. Return 200 OK quickly (don't block on regeneration)

    Signature verification pattern (like Stripe):
    ```typescript
    const expectedSignature = `sha256=${crypto.createHmac('sha256', secret).update(payload).digest('hex')}`;
    if (signature !== expectedSignature) return error(401, 'Invalid signature');
    ```

    Security:
    - Verify signature before any processing
    - Log webhook delivery ID for debugging
    - Return 200 even for ignored events (GitHub expects this)
  </action>
  <verify>TypeScript compiles: `npm run check`</verify>
  <done>Webhook endpoint receives and validates GitHub push events</done>
</task>

<task type="auto">
  <name>Task 2: Implement auto-regeneration logic</name>
  <files>src/lib/server/autosync.ts</files>
  <action>
    Create new service module for auto-sync regeneration:

    `async function triggerAutoRegeneration(repoId: string): Promise<void>`

    1. Fetch repository from database with user profile (need github_token)
    2. Check auto_sync_enabled is true
    3. Check user's plan allows auto-sync (Pro and Team only, not Single Repo)
    4. For Pro/Team: Check monthly usage limits (30/100 repos)
    5. If checks pass:
       - Import and use existing doc generation logic from generate endpoint
       - Regenerate all 4 doc types (readme, api, architecture, setup)
       - Update last_synced_at timestamp
       - Increment repos_used_this_month if applicable
    6. Log success/failure for debugging

    Rate limiting:
    - Add cooldown check: Don't regenerate if last_synced_at < 5 minutes ago
    - Prevents rapid-fire regenerations from multiple quick pushes

    Error handling:
    - Don't throw - log errors and fail silently
    - User will see stale docs but webhook shouldn't fail
  </action>
  <verify>TypeScript compiles: `npm run check`</verify>
  <done>Auto-regeneration function handles plan checks, rate limits, and triggers doc generation</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete auto-sync webhook infrastructure</what-built>
  <how-to-verify>
    1. Apply database migration in Supabase Dashboard
    2. Start dev server: `npm run dev`
    3. Create a test repository entry in database with auto_sync_enabled = true
    4. Use curl to simulate a GitHub webhook:
       ```bash
       # Generate test signature
       SECRET="test-secret"
       PAYLOAD='{"ref":"refs/heads/main","repository":{"full_name":"test/repo"}}'
       SIGNATURE="sha256=$(echo -n "$PAYLOAD" | openssl dgst -sha256 -hmac "$SECRET" | cut -d' ' -f2)"

       curl -X POST http://localhost:5173/api/github/webhook \
         -H "Content-Type: application/json" \
         -H "X-GitHub-Event: push" \
         -H "X-Hub-Signature-256: $SIGNATURE" \
         -H "X-GitHub-Delivery: test-123" \
         -d "$PAYLOAD"
       ```
    5. Check server logs for webhook processing
    6. Verify 200 response received
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run check` passes without errors
- [ ] `npm run build` succeeds
- [ ] Webhook endpoint validates signatures correctly
- [ ] Auto-regeneration respects plan limits
- [ ] Rate limiting prevents rapid regenerations
- [ ] Webhook returns 200 for valid requests
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- GitHub webhooks processed securely
- Docs regenerate automatically on push (for Pro/Team users)
- Phase 10 complete
</success_criteria>

<output>
After completion, create `.planning/phases/10-auto-sync/10-02-SUMMARY.md`:

# Phase 10 Plan 02: Webhook Processing Summary

**[Substantive one-liner]**

## Accomplishments
- GitHub webhook receiver endpoint
- Auto-regeneration logic with plan/usage checks
- Rate limiting for rapid pushes

## Files Created/Modified
- `src/routes/api/github/webhook/+server.ts`
- `src/lib/server/autosync.ts`

## Decisions Made
[Key decisions]

## Issues Encountered
[Problems and resolutions]

## Next Step
Phase 10 complete. Ready for Phase 11 (Team collaboration) or launch activities.
</output>
