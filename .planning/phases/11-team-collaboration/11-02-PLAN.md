# Plan 11-02: Team Invitation System

## Objective

Implement a complete team invitation workflow allowing team owners/admins to invite new members via email, with secure token-based acceptance.

## Prerequisites

- Plan 11-01 (Database Schema) completed
- Email service configured (or console logging for development)
- Existing auth system

## Tasks

### 1. Create Team Server Functions

**File:** `src/lib/server/teams.ts`

```typescript
import { supabaseAdmin } from './supabase';
import { nanoid } from 'nanoid';
import type { Team, TeamMember, TeamInvitation } from '$lib/types';

// Create a new team
export async function createTeam(
  userId: string,
  name: string
): Promise<Team> {
  const slug = generateSlug(name);

  const { data, error } = await supabaseAdmin
    .from('teams')
    .insert({
      name,
      slug,
      owner_id: userId
    })
    .select()
    .single();

  if (error) throw error;
  return data;
}

// Get user's teams
export async function getUserTeams(userId: string): Promise<Team[]> {
  const { data, error } = await supabaseAdmin
    .from('team_members')
    .select('teams(*)')
    .eq('user_id', userId);

  if (error) throw error;
  return data.map(d => d.teams).filter(Boolean);
}

// Get team by ID with members
export async function getTeamWithMembers(
  teamId: string,
  userId: string
): Promise<{ team: Team; members: TeamMember[]; isAdmin: boolean }> {
  // Check membership
  const { data: membership } = await supabaseAdmin
    .from('team_members')
    .select('role')
    .eq('team_id', teamId)
    .eq('user_id', userId)
    .single();

  if (!membership) {
    throw new Error('Not a member of this team');
  }

  // Get team
  const { data: team, error: teamError } = await supabaseAdmin
    .from('teams')
    .select('*')
    .eq('id', teamId)
    .single();

  if (teamError) throw teamError;

  // Get members with profiles
  const { data: members, error: membersError } = await supabaseAdmin
    .from('team_members')
    .select(`
      *,
      profiles:user_id (
        id,
        email,
        github_username
      )
    `)
    .eq('team_id', teamId)
    .order('joined_at', { ascending: true });

  if (membersError) throw membersError;

  return {
    team,
    members: members.map(m => ({
      ...m,
      profile: m.profiles
    })),
    isAdmin: membership.role === 'owner' || membership.role === 'admin'
  };
}

// Create invitation
export async function createInvitation(
  teamId: string,
  email: string,
  role: 'admin' | 'member',
  invitedBy: string
): Promise<TeamInvitation> {
  // Check seat limit
  const { data: team } = await supabaseAdmin
    .from('teams')
    .select('max_seats')
    .eq('id', teamId)
    .single();

  const { count: memberCount } = await supabaseAdmin
    .from('team_members')
    .select('*', { count: 'exact', head: true })
    .eq('team_id', teamId);

  const { count: pendingCount } = await supabaseAdmin
    .from('team_invitations')
    .select('*', { count: 'exact', head: true })
    .eq('team_id', teamId)
    .is('accepted_at', null);

  if ((memberCount || 0) + (pendingCount || 0) >= (team?.max_seats || 5)) {
    throw new Error('Team has reached maximum seats');
  }

  // Check if already a member
  const { data: existingProfile } = await supabaseAdmin
    .from('profiles')
    .select('id')
    .eq('email', email)
    .single();

  if (existingProfile) {
    const { data: existingMember } = await supabaseAdmin
      .from('team_members')
      .select('id')
      .eq('team_id', teamId)
      .eq('user_id', existingProfile.id)
      .single();

    if (existingMember) {
      throw new Error('User is already a team member');
    }
  }

  // Create invitation with unique token
  const token = nanoid(32);

  const { data, error } = await supabaseAdmin
    .from('team_invitations')
    .insert({
      team_id: teamId,
      email: email.toLowerCase(),
      role,
      invited_by: invitedBy,
      token
    })
    .select()
    .single();

  if (error) {
    if (error.code === '23505') {
      throw new Error('An invitation has already been sent to this email');
    }
    throw error;
  }

  return data;
}

// Accept invitation
export async function acceptInvitation(
  token: string,
  userId: string
): Promise<{ team: Team; role: string }> {
  // Get invitation
  const { data: invitation, error: invError } = await supabaseAdmin
    .from('team_invitations')
    .select('*, teams(*)')
    .eq('token', token)
    .is('accepted_at', null)
    .single();

  if (invError || !invitation) {
    throw new Error('Invalid or expired invitation');
  }

  if (new Date(invitation.expires_at) < new Date()) {
    throw new Error('Invitation has expired');
  }

  // Verify email matches
  const { data: profile } = await supabaseAdmin
    .from('profiles')
    .select('email')
    .eq('id', userId)
    .single();

  if (profile?.email?.toLowerCase() !== invitation.email.toLowerCase()) {
    throw new Error('This invitation was sent to a different email address');
  }

  // Add member
  const { error: memberError } = await supabaseAdmin
    .from('team_members')
    .insert({
      team_id: invitation.team_id,
      user_id: userId,
      role: invitation.role
    });

  if (memberError) {
    if (memberError.code === '23505') {
      throw new Error('You are already a member of this team');
    }
    throw memberError;
  }

  // Mark invitation as accepted
  await supabaseAdmin
    .from('team_invitations')
    .update({ accepted_at: new Date().toISOString() })
    .eq('id', invitation.id);

  return { team: invitation.teams, role: invitation.role };
}

// Get pending invitations for team
export async function getTeamInvitations(
  teamId: string
): Promise<TeamInvitation[]> {
  const { data, error } = await supabaseAdmin
    .from('team_invitations')
    .select('*')
    .eq('team_id', teamId)
    .is('accepted_at', null)
    .gt('expires_at', new Date().toISOString())
    .order('created_at', { ascending: false });

  if (error) throw error;
  return data || [];
}

// Cancel invitation
export async function cancelInvitation(invitationId: string): Promise<void> {
  const { error } = await supabaseAdmin
    .from('team_invitations')
    .delete()
    .eq('id', invitationId);

  if (error) throw error;
}

// Remove team member
export async function removeTeamMember(
  teamId: string,
  memberId: string,
  removedBy: string
): Promise<void> {
  // Can't remove owner
  const { data: member } = await supabaseAdmin
    .from('team_members')
    .select('role, user_id')
    .eq('id', memberId)
    .single();

  if (member?.role === 'owner') {
    throw new Error('Cannot remove team owner');
  }

  // Check remover is admin
  const { data: remover } = await supabaseAdmin
    .from('team_members')
    .select('role')
    .eq('team_id', teamId)
    .eq('user_id', removedBy)
    .single();

  if (remover?.role !== 'owner' && remover?.role !== 'admin') {
    throw new Error('Only team admins can remove members');
  }

  const { error } = await supabaseAdmin
    .from('team_members')
    .delete()
    .eq('id', memberId);

  if (error) throw error;
}

// Leave team
export async function leaveTeam(
  teamId: string,
  userId: string
): Promise<void> {
  const { data: member } = await supabaseAdmin
    .from('team_members')
    .select('role')
    .eq('team_id', teamId)
    .eq('user_id', userId)
    .single();

  if (member?.role === 'owner') {
    throw new Error('Team owner cannot leave. Transfer ownership or delete the team.');
  }

  const { error } = await supabaseAdmin
    .from('team_members')
    .delete()
    .eq('team_id', teamId)
    .eq('user_id', userId);

  if (error) throw error;
}

// Update member role
export async function updateMemberRole(
  memberId: string,
  newRole: 'admin' | 'member',
  updatedBy: string
): Promise<void> {
  const { data: member } = await supabaseAdmin
    .from('team_members')
    .select('team_id, role')
    .eq('id', memberId)
    .single();

  if (!member) throw new Error('Member not found');
  if (member.role === 'owner') throw new Error('Cannot change owner role');

  // Check updater is owner or admin
  const { data: updater } = await supabaseAdmin
    .from('team_members')
    .select('role')
    .eq('team_id', member.team_id)
    .eq('user_id', updatedBy)
    .single();

  if (updater?.role !== 'owner' && updater?.role !== 'admin') {
    throw new Error('Only team admins can change roles');
  }

  const { error } = await supabaseAdmin
    .from('team_members')
    .update({ role: newRole })
    .eq('id', memberId);

  if (error) throw error;
}

// Helper: generate slug from name
function generateSlug(name: string): string {
  const base = name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '');
  return `${base}-${nanoid(6)}`;
}
```

### 2. Create API Endpoints

**File:** `src/routes/api/teams/+server.ts`

```typescript
import { json, error } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { createTeam, getUserTeams } from '$lib/server/teams';

// GET /api/teams - Get user's teams
export const GET: RequestHandler = async ({ locals }) => {
  if (!locals.user) {
    throw error(401, 'Unauthorized');
  }

  try {
    const teams = await getUserTeams(locals.user.id);
    return json({ teams });
  } catch (err) {
    console.error('Error fetching teams:', err);
    throw error(500, 'Failed to fetch teams');
  }
};

// POST /api/teams - Create new team
export const POST: RequestHandler = async ({ locals, request }) => {
  if (!locals.user) {
    throw error(401, 'Unauthorized');
  }

  // Check if user has Team tier
  if (locals.profile?.subscription_tier !== 'team') {
    throw error(403, 'Team tier subscription required');
  }

  try {
    const { name } = await request.json();

    if (!name || name.trim().length < 2) {
      throw error(400, 'Team name must be at least 2 characters');
    }

    const team = await createTeam(locals.user.id, name.trim());
    return json({ team });
  } catch (err) {
    console.error('Error creating team:', err);
    throw error(500, err instanceof Error ? err.message : 'Failed to create team');
  }
};
```

**File:** `src/routes/api/teams/[id]/+server.ts`

```typescript
import { json, error } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { getTeamWithMembers } from '$lib/server/teams';
import { supabaseAdmin } from '$lib/server/supabase';

// GET /api/teams/[id] - Get team details
export const GET: RequestHandler = async ({ params, locals }) => {
  if (!locals.user) {
    throw error(401, 'Unauthorized');
  }

  try {
    const result = await getTeamWithMembers(params.id, locals.user.id);
    return json(result);
  } catch (err) {
    console.error('Error fetching team:', err);
    throw error(500, err instanceof Error ? err.message : 'Failed to fetch team');
  }
};

// DELETE /api/teams/[id] - Delete team (owner only)
export const DELETE: RequestHandler = async ({ params, locals }) => {
  if (!locals.user) {
    throw error(401, 'Unauthorized');
  }

  // Verify ownership
  const { data: team } = await supabaseAdmin
    .from('teams')
    .select('owner_id')
    .eq('id', params.id)
    .single();

  if (team?.owner_id !== locals.user.id) {
    throw error(403, 'Only the team owner can delete the team');
  }

  try {
    await supabaseAdmin.from('teams').delete().eq('id', params.id);
    return json({ success: true });
  } catch (err) {
    console.error('Error deleting team:', err);
    throw error(500, 'Failed to delete team');
  }
};
```

**File:** `src/routes/api/teams/[id]/invitations/+server.ts`

```typescript
import { json, error } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { createInvitation, getTeamInvitations, cancelInvitation } from '$lib/server/teams';
import { supabaseAdmin } from '$lib/server/supabase';

// GET - List pending invitations
export const GET: RequestHandler = async ({ params, locals }) => {
  if (!locals.user) {
    throw error(401, 'Unauthorized');
  }

  // Check admin access
  const { data: member } = await supabaseAdmin
    .from('team_members')
    .select('role')
    .eq('team_id', params.id)
    .eq('user_id', locals.user.id)
    .single();

  if (!member || !['owner', 'admin'].includes(member.role)) {
    throw error(403, 'Admin access required');
  }

  try {
    const invitations = await getTeamInvitations(params.id);
    return json({ invitations });
  } catch (err) {
    console.error('Error fetching invitations:', err);
    throw error(500, 'Failed to fetch invitations');
  }
};

// POST - Create invitation
export const POST: RequestHandler = async ({ params, locals, request }) => {
  if (!locals.user) {
    throw error(401, 'Unauthorized');
  }

  // Check admin access
  const { data: member } = await supabaseAdmin
    .from('team_members')
    .select('role')
    .eq('team_id', params.id)
    .eq('user_id', locals.user.id)
    .single();

  if (!member || !['owner', 'admin'].includes(member.role)) {
    throw error(403, 'Admin access required');
  }

  try {
    const { email, role = 'member' } = await request.json();

    if (!email || !email.includes('@')) {
      throw error(400, 'Valid email required');
    }

    const invitation = await createInvitation(
      params.id,
      email,
      role,
      locals.user.id
    );

    // TODO: Send email with invitation link
    // For now, return the token for testing
    const inviteUrl = `${process.env.PUBLIC_APP_URL}/teams/invite/${invitation.token}`;

    return json({ invitation, inviteUrl });
  } catch (err) {
    console.error('Error creating invitation:', err);
    throw error(500, err instanceof Error ? err.message : 'Failed to create invitation');
  }
};

// DELETE - Cancel invitation
export const DELETE: RequestHandler = async ({ params, locals, url }) => {
  if (!locals.user) {
    throw error(401, 'Unauthorized');
  }

  const invitationId = url.searchParams.get('invitationId');
  if (!invitationId) {
    throw error(400, 'Invitation ID required');
  }

  try {
    await cancelInvitation(invitationId);
    return json({ success: true });
  } catch (err) {
    console.error('Error cancelling invitation:', err);
    throw error(500, 'Failed to cancel invitation');
  }
};
```

**File:** `src/routes/api/teams/[id]/members/+server.ts`

```typescript
import { json, error } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { removeTeamMember, updateMemberRole, leaveTeam } from '$lib/server/teams';

// DELETE - Remove member or leave team
export const DELETE: RequestHandler = async ({ params, locals, url }) => {
  if (!locals.user) {
    throw error(401, 'Unauthorized');
  }

  const memberId = url.searchParams.get('memberId');

  try {
    if (memberId) {
      // Admin removing a member
      await removeTeamMember(params.id, memberId, locals.user.id);
    } else {
      // User leaving team
      await leaveTeam(params.id, locals.user.id);
    }
    return json({ success: true });
  } catch (err) {
    console.error('Error removing member:', err);
    throw error(500, err instanceof Error ? err.message : 'Failed to remove member');
  }
};

// PATCH - Update member role
export const PATCH: RequestHandler = async ({ params, locals, request }) => {
  if (!locals.user) {
    throw error(401, 'Unauthorized');
  }

  try {
    const { memberId, role } = await request.json();

    if (!memberId || !['admin', 'member'].includes(role)) {
      throw error(400, 'Valid member ID and role required');
    }

    await updateMemberRole(memberId, role, locals.user.id);
    return json({ success: true });
  } catch (err) {
    console.error('Error updating role:', err);
    throw error(500, err instanceof Error ? err.message : 'Failed to update role');
  }
};
```

### 3. Create Invitation Accept Page

**File:** `src/routes/teams/invite/[token]/+page.server.ts`

```typescript
import { redirect, error } from '@sveltejs/kit';
import type { PageServerLoad, Actions } from './$types';
import { acceptInvitation } from '$lib/server/teams';
import { supabaseAdmin } from '$lib/server/supabase';

export const load: PageServerLoad = async ({ params }) => {
  // Get invitation details
  const { data: invitation, error: err } = await supabaseAdmin
    .from('team_invitations')
    .select(`
      *,
      teams (name, slug),
      profiles:invited_by (github_username, email)
    `)
    .eq('token', params.token)
    .is('accepted_at', null)
    .single();

  if (err || !invitation) {
    throw error(404, 'Invitation not found or already used');
  }

  if (new Date(invitation.expires_at) < new Date()) {
    throw error(410, 'Invitation has expired');
  }

  return {
    invitation: {
      teamName: invitation.teams?.name,
      role: invitation.role,
      invitedBy: invitation.profiles?.github_username || invitation.profiles?.email,
      expiresAt: invitation.expires_at
    },
    token: params.token
  };
};

export const actions: Actions = {
  accept: async ({ params, locals }) => {
    if (!locals.user) {
      throw redirect(303, `/auth/login?redirect=/teams/invite/${params.token}`);
    }

    try {
      const { team } = await acceptInvitation(params.token, locals.user.id);
      throw redirect(303, `/dashboard?team=${team.id}`);
    } catch (err) {
      if (err instanceof Response) throw err;
      return { error: err instanceof Error ? err.message : 'Failed to accept invitation' };
    }
  }
};
```

**File:** `src/routes/teams/invite/[token]/+page.svelte`

```svelte
<script lang="ts">
  import { enhance } from '$app/forms';

  export let data;
  export let form;
</script>

<svelte:head>
  <title>Team Invitation - Codec8</title>
</svelte:head>

<div class="min-h-screen bg-dark-900 flex items-center justify-center px-4">
  <div class="card max-w-md w-full p-8">
    <div class="text-center mb-8">
      <div class="w-16 h-16 bg-accent/20 rounded-full flex items-center justify-center mx-auto mb-4">
        <svg class="w-8 h-8 text-accent" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
            d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
        </svg>
      </div>

      <h1 class="text-2xl font-bold text-white mb-2">
        Join {data.invitation.teamName}
      </h1>
      <p class="text-text-secondary">
        {data.invitation.invitedBy} invited you to join as {data.invitation.role === 'admin' ? 'an admin' : 'a member'}
      </p>
    </div>

    {#if form?.error}
      <div class="mb-6 p-4 bg-error/20 border border-error/30 rounded-lg text-error text-sm">
        {form.error}
      </div>
    {/if}

    <form method="POST" action="?/accept" use:enhance>
      <button type="submit" class="btn-primary w-full">
        Accept Invitation
      </button>
    </form>

    <p class="text-center text-text-muted text-sm mt-6">
      This invitation expires on {new Date(data.invitation.expiresAt).toLocaleDateString()}
    </p>
  </div>
</div>
```

### 4. Create Team Management UI Component

**File:** `src/lib/components/TeamMembers.svelte`

```svelte
<script lang="ts">
  import type { TeamMember, TeamInvitation } from '$lib/types';
  import { showToast } from '$lib/stores/toast';

  export let members: TeamMember[] = [];
  export let invitations: TeamInvitation[] = [];
  export let isAdmin = false;
  export let currentUserId: string;
  export let teamId: string;

  let inviteEmail = '';
  let inviteRole: 'admin' | 'member' = 'member';
  let inviting = false;

  async function sendInvite() {
    if (!inviteEmail.trim()) return;

    inviting = true;
    try {
      const res = await fetch(`/api/teams/${teamId}/invitations`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email: inviteEmail.trim(), role: inviteRole })
      });

      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.message || 'Failed to send invitation');
      }

      const { invitation } = await res.json();
      invitations = [...invitations, invitation];
      inviteEmail = '';
      showToast('Invitation sent!', 'success');
    } catch (err) {
      showToast(err instanceof Error ? err.message : 'Failed to send invitation', 'error');
    } finally {
      inviting = false;
    }
  }

  async function cancelInvite(id: string) {
    try {
      const res = await fetch(`/api/teams/${teamId}/invitations?invitationId=${id}`, {
        method: 'DELETE'
      });

      if (!res.ok) throw new Error('Failed to cancel');

      invitations = invitations.filter(i => i.id !== id);
      showToast('Invitation cancelled', 'success');
    } catch (err) {
      showToast('Failed to cancel invitation', 'error');
    }
  }

  async function removeMember(memberId: string) {
    if (!confirm('Remove this team member?')) return;

    try {
      const res = await fetch(`/api/teams/${teamId}/members?memberId=${memberId}`, {
        method: 'DELETE'
      });

      if (!res.ok) throw new Error('Failed to remove');

      members = members.filter(m => m.id !== memberId);
      showToast('Member removed', 'success');
    } catch (err) {
      showToast('Failed to remove member', 'error');
    }
  }

  async function changeRole(memberId: string, newRole: 'admin' | 'member') {
    try {
      const res = await fetch(`/api/teams/${teamId}/members`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ memberId, role: newRole })
      });

      if (!res.ok) throw new Error('Failed to update');

      members = members.map(m =>
        m.id === memberId ? { ...m, role: newRole } : m
      );
      showToast('Role updated', 'success');
    } catch (err) {
      showToast('Failed to update role', 'error');
    }
  }

  function getRoleBadgeClass(role: string) {
    switch (role) {
      case 'owner': return 'bg-purple-500/20 text-purple-400 border-purple-500/30';
      case 'admin': return 'bg-accent/20 text-accent border-accent/30';
      default: return 'bg-dark-600 text-text-secondary border-dark-500';
    }
  }
</script>

<div class="space-y-6">
  <!-- Members List -->
  <div>
    <h3 class="text-lg font-semibold text-white mb-4">Team Members ({members.length})</h3>
    <div class="space-y-2">
      {#each members as member}
        <div class="flex items-center justify-between p-3 bg-dark-700 rounded-lg">
          <div class="flex items-center gap-3">
            <div class="w-10 h-10 bg-dark-600 rounded-full flex items-center justify-center">
              <span class="text-text-secondary font-medium">
                {member.profile?.github_username?.[0]?.toUpperCase() || '?'}
              </span>
            </div>
            <div>
              <p class="text-white font-medium">
                {member.profile?.github_username || member.profile?.email}
                {#if member.user_id === currentUserId}
                  <span class="text-text-muted text-sm">(you)</span>
                {/if}
              </p>
              <p class="text-text-muted text-sm">{member.profile?.email}</p>
            </div>
          </div>

          <div class="flex items-center gap-2">
            <span class="badge {getRoleBadgeClass(member.role)} capitalize">
              {member.role}
            </span>

            {#if isAdmin && member.role !== 'owner' && member.user_id !== currentUserId}
              <div class="flex items-center gap-1">
                <select
                  value={member.role}
                  on:change={(e) => changeRole(member.id, e.currentTarget.value as 'admin' | 'member')}
                  class="select py-1 px-2 text-sm bg-dark-600"
                >
                  <option value="member">Member</option>
                  <option value="admin">Admin</option>
                </select>
                <button
                  on:click={() => removeMember(member.id)}
                  class="p-2 text-text-muted hover:text-error transition-colors"
                  title="Remove member"
                >
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </button>
              </div>
            {/if}
          </div>
        </div>
      {/each}
    </div>
  </div>

  <!-- Pending Invitations -->
  {#if isAdmin && invitations.length > 0}
    <div>
      <h3 class="text-lg font-semibold text-white mb-4">Pending Invitations ({invitations.length})</h3>
      <div class="space-y-2">
        {#each invitations as invite}
          <div class="flex items-center justify-between p-3 bg-dark-700/50 rounded-lg border border-dashed border-dark-500">
            <div>
              <p class="text-text-secondary">{invite.email}</p>
              <p class="text-text-muted text-sm">
                Invited as {invite.role} - Expires {new Date(invite.expires_at).toLocaleDateString()}
              </p>
            </div>
            <button
              on:click={() => cancelInvite(invite.id)}
              class="text-text-muted hover:text-error text-sm"
            >
              Cancel
            </button>
          </div>
        {/each}
      </div>
    </div>
  {/if}

  <!-- Invite Form -->
  {#if isAdmin}
    <div class="pt-4 border-t border-dark-500">
      <h3 class="text-lg font-semibold text-white mb-4">Invite New Member</h3>
      <form on:submit|preventDefault={sendInvite} class="flex gap-3">
        <input
          type="email"
          bind:value={inviteEmail}
          placeholder="colleague@company.com"
          class="input flex-1"
          disabled={inviting}
        />
        <select bind:value={inviteRole} class="select w-32" disabled={inviting}>
          <option value="member">Member</option>
          <option value="admin">Admin</option>
        </select>
        <button type="submit" class="btn-primary" disabled={inviting || !inviteEmail.trim()}>
          {inviting ? 'Sending...' : 'Invite'}
        </button>
      </form>
    </div>
  {/if}
</div>
```

## Verification

- [ ] Team creation works for Team tier users
- [ ] Invitations are sent with unique tokens
- [ ] Invitation acceptance adds user to team
- [ ] Expired invitations are rejected
- [ ] Email mismatch is handled
- [ ] Seat limit is enforced
- [ ] Role-based access controls work
- [ ] Team owner cannot be removed
- [ ] Members can leave but not owners

## Testing Scenarios

1. Create team → verify owner is added as member
2. Send invitation → verify token generated
3. Accept invitation → verify membership created
4. Try accepting expired invitation → verify rejection
5. Try exceeding seat limit → verify error
6. Admin changes member role → verify update
7. Admin removes member → verify deletion
8. Owner tries to leave → verify error
9. Member leaves team → verify removal

## Notes

- Email sending is TODO - currently returns invite URL for testing
- Consider adding email verification for invitations
- Rate limit invitation creation to prevent spam
