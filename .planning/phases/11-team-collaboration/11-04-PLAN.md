# Plan 11-04: Custom Documentation Templates

## Objective

Allow Team tier users to create and manage custom prompt templates for documentation generation, enabling consistent documentation styles across their organization.

## Prerequisites

- Plan 11-01 (Database Schema) completed
- `doc_templates` table created
- Existing doc generation with Claude API

## Tasks

### 1. Create Template Server Functions

**File:** `src/lib/server/templates.ts`

```typescript
import { supabaseAdmin } from './supabase';
import type { DocTemplate } from '$lib/types';

const DEFAULT_TEMPLATES: Record<string, string> = {
  readme: `Generate a comprehensive README.md for this repository.
Include:
- Project title and description
- Features and highlights
- Installation instructions
- Usage examples
- Configuration options
- Contributing guidelines
- License information

Use clear, concise language. Format in proper Markdown.`,

  api: `Generate API documentation for this codebase.
Include:
- Overview of available endpoints/functions
- Request/response formats
- Authentication requirements
- Error codes and handling
- Usage examples for each endpoint
- Rate limits if applicable

Format as structured Markdown with code examples.`,

  architecture: `Generate architecture documentation for this codebase.
Include:
- System overview and design philosophy
- Component breakdown
- Data flow diagrams (Mermaid syntax)
- Key design decisions
- Dependencies and integrations
- Deployment architecture

Use Mermaid diagrams where helpful.`,

  setup: `Generate a setup guide for this repository.
Include:
- Prerequisites and requirements
- Step-by-step installation
- Environment configuration
- Database setup if needed
- Development server instructions
- Troubleshooting common issues

Format as a clear, numbered guide.`
};

export async function getTeamTemplates(teamId: string): Promise<DocTemplate[]> {
  const { data, error } = await supabaseAdmin
    .from('doc_templates')
    .select('*')
    .eq('team_id', teamId)
    .order('doc_type')
    .order('name');

  if (error) throw error;
  return data || [];
}

export async function getTemplate(
  teamId: string | null,
  docType: string
): Promise<string> {
  // If team has a default template for this type, use it
  if (teamId) {
    const { data } = await supabaseAdmin
      .from('doc_templates')
      .select('prompt_template')
      .eq('team_id', teamId)
      .eq('doc_type', docType)
      .eq('is_default', true)
      .single();

    if (data?.prompt_template) {
      return data.prompt_template;
    }
  }

  // Fall back to built-in default
  return DEFAULT_TEMPLATES[docType] || DEFAULT_TEMPLATES.readme;
}

export async function createTemplate(
  teamId: string,
  docType: string,
  name: string,
  promptTemplate: string,
  createdBy: string,
  isDefault: boolean = false
): Promise<DocTemplate> {
  // If setting as default, unset existing defaults
  if (isDefault) {
    await supabaseAdmin
      .from('doc_templates')
      .update({ is_default: false })
      .eq('team_id', teamId)
      .eq('doc_type', docType);
  }

  const { data, error } = await supabaseAdmin
    .from('doc_templates')
    .insert({
      team_id: teamId,
      doc_type: docType,
      name,
      prompt_template: promptTemplate,
      is_default: isDefault,
      created_by: createdBy
    })
    .select()
    .single();

  if (error) {
    if (error.code === '23505') {
      throw new Error('A template with this name already exists');
    }
    throw error;
  }

  return data;
}

export async function updateTemplate(
  templateId: string,
  updates: {
    name?: string;
    prompt_template?: string;
    is_default?: boolean;
  },
  teamId: string
): Promise<DocTemplate> {
  // If setting as default, get doc_type and unset others
  if (updates.is_default) {
    const { data: existing } = await supabaseAdmin
      .from('doc_templates')
      .select('doc_type')
      .eq('id', templateId)
      .single();

    if (existing) {
      await supabaseAdmin
        .from('doc_templates')
        .update({ is_default: false })
        .eq('team_id', teamId)
        .eq('doc_type', existing.doc_type);
    }
  }

  const { data, error } = await supabaseAdmin
    .from('doc_templates')
    .update({
      ...updates,
      updated_at: new Date().toISOString()
    })
    .eq('id', templateId)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function deleteTemplate(templateId: string): Promise<void> {
  const { error } = await supabaseAdmin
    .from('doc_templates')
    .delete()
    .eq('id', templateId);

  if (error) throw error;
}

export async function duplicateTemplate(
  templateId: string,
  newName: string,
  createdBy: string
): Promise<DocTemplate> {
  const { data: original } = await supabaseAdmin
    .from('doc_templates')
    .select('*')
    .eq('id', templateId)
    .single();

  if (!original) throw new Error('Template not found');

  const { data, error } = await supabaseAdmin
    .from('doc_templates')
    .insert({
      team_id: original.team_id,
      doc_type: original.doc_type,
      name: newName,
      prompt_template: original.prompt_template,
      is_default: false,
      created_by: createdBy
    })
    .select()
    .single();

  if (error) throw error;
  return data;
}

// Get default templates for display/reference
export function getDefaultTemplates(): Record<string, string> {
  return { ...DEFAULT_TEMPLATES };
}
```

### 2. Create Template API Endpoints

**File:** `src/routes/api/templates/+server.ts`

```typescript
import { json, error } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { getTeamTemplates, createTemplate, getDefaultTemplates } from '$lib/server/templates';
import { supabaseAdmin } from '$lib/server/supabase';

// GET /api/templates - List team templates or defaults
export const GET: RequestHandler = async ({ locals, url }) => {
  if (!locals.user) {
    throw error(401, 'Unauthorized');
  }

  const showDefaults = url.searchParams.get('defaults') === 'true';

  if (showDefaults) {
    return json({ templates: getDefaultTemplates() });
  }

  const teamId = locals.profile?.default_team_id;
  if (!teamId) {
    throw error(400, 'No team selected');
  }

  try {
    const templates = await getTeamTemplates(teamId);
    return json({ templates });
  } catch (err) {
    console.error('Error fetching templates:', err);
    throw error(500, 'Failed to fetch templates');
  }
};

// POST /api/templates - Create new template
export const POST: RequestHandler = async ({ locals, request }) => {
  if (!locals.user) {
    throw error(401, 'Unauthorized');
  }

  // Team tier required
  if (locals.profile?.subscription_tier !== 'team') {
    throw error(403, 'Team subscription required');
  }

  const teamId = locals.profile?.default_team_id;
  if (!teamId) {
    throw error(400, 'No team selected');
  }

  // Verify user is team admin
  const { data: member } = await supabaseAdmin
    .from('team_members')
    .select('role')
    .eq('team_id', teamId)
    .eq('user_id', locals.user.id)
    .single();

  if (!member || !['owner', 'admin'].includes(member.role)) {
    throw error(403, 'Admin access required');
  }

  try {
    const { docType, name, promptTemplate, isDefault } = await request.json();

    if (!docType || !name || !promptTemplate) {
      throw error(400, 'Missing required fields');
    }

    const validTypes = ['readme', 'api', 'architecture', 'setup'];
    if (!validTypes.includes(docType)) {
      throw error(400, 'Invalid document type');
    }

    const template = await createTemplate(
      teamId,
      docType,
      name.trim(),
      promptTemplate,
      locals.user.id,
      isDefault || false
    );

    return json({ template });
  } catch (err) {
    console.error('Error creating template:', err);
    throw error(500, err instanceof Error ? err.message : 'Failed to create template');
  }
};
```

**File:** `src/routes/api/templates/[id]/+server.ts`

```typescript
import { json, error } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { updateTemplate, deleteTemplate, duplicateTemplate } from '$lib/server/templates';
import { supabaseAdmin } from '$lib/server/supabase';

// Helper to verify admin access
async function verifyAdminAccess(templateId: string, userId: string): Promise<string> {
  const { data: template } = await supabaseAdmin
    .from('doc_templates')
    .select('team_id')
    .eq('id', templateId)
    .single();

  if (!template) throw new Error('Template not found');

  const { data: member } = await supabaseAdmin
    .from('team_members')
    .select('role')
    .eq('team_id', template.team_id)
    .eq('user_id', userId)
    .single();

  if (!member || !['owner', 'admin'].includes(member.role)) {
    throw new Error('Admin access required');
  }

  return template.team_id;
}

// PATCH /api/templates/[id] - Update template
export const PATCH: RequestHandler = async ({ params, locals, request }) => {
  if (!locals.user) {
    throw error(401, 'Unauthorized');
  }

  try {
    const teamId = await verifyAdminAccess(params.id, locals.user.id);
    const updates = await request.json();

    const template = await updateTemplate(params.id, updates, teamId);
    return json({ template });
  } catch (err) {
    console.error('Error updating template:', err);
    throw error(500, err instanceof Error ? err.message : 'Failed to update template');
  }
};

// DELETE /api/templates/[id] - Delete template
export const DELETE: RequestHandler = async ({ params, locals }) => {
  if (!locals.user) {
    throw error(401, 'Unauthorized');
  }

  try {
    await verifyAdminAccess(params.id, locals.user.id);
    await deleteTemplate(params.id);
    return json({ success: true });
  } catch (err) {
    console.error('Error deleting template:', err);
    throw error(500, err instanceof Error ? err.message : 'Failed to delete template');
  }
};

// POST /api/templates/[id]/duplicate - Duplicate template
export const POST: RequestHandler = async ({ params, locals, request }) => {
  if (!locals.user) {
    throw error(401, 'Unauthorized');
  }

  try {
    await verifyAdminAccess(params.id, locals.user.id);
    const { name } = await request.json();

    if (!name?.trim()) {
      throw error(400, 'Name required');
    }

    const template = await duplicateTemplate(params.id, name.trim(), locals.user.id);
    return json({ template });
  } catch (err) {
    console.error('Error duplicating template:', err);
    throw error(500, err instanceof Error ? err.message : 'Failed to duplicate template');
  }
};
```

### 3. Update Doc Generation to Use Templates

**File:** `src/routes/api/docs/generate/+server.ts` (modification)

```typescript
// Add import
import { getTemplate } from '$lib/server/templates';

// In the generation logic, replace hardcoded prompts:
const promptTemplate = await getTemplate(
  profile?.default_team_id || null,
  type
);

// Use the template in Claude API call
const systemPrompt = `You are an expert technical writer. ${promptTemplate}

Repository: ${repo.full_name}
Default Branch: ${repo.default_branch}
Description: ${repo.description || 'No description provided'}

Analyze the following code structure and content:
${codeContext}`;
```

### 4. Create Template Editor Component

**File:** `src/lib/components/TemplateEditor.svelte`

```svelte
<script lang="ts">
  import type { DocTemplate } from '$lib/types';
  import { showToast } from '$lib/stores/toast';
  import { createEventDispatcher } from 'svelte';

  const dispatch = createEventDispatcher();

  export let template: DocTemplate | null = null;
  export let mode: 'create' | 'edit' = 'create';

  const docTypes = [
    { value: 'readme', label: 'README' },
    { value: 'api', label: 'API Documentation' },
    { value: 'architecture', label: 'Architecture' },
    { value: 'setup', label: 'Setup Guide' }
  ];

  let name = template?.name || '';
  let docType = template?.doc_type || 'readme';
  let promptTemplate = template?.prompt_template || '';
  let isDefault = template?.is_default || false;
  let saving = false;

  // Template variables hint
  const variables = [
    '{{repo_name}} - Repository name',
    '{{repo_full_name}} - owner/repo format',
    '{{branch}} - Default branch',
    '{{description}} - Repo description',
    '{{language}} - Primary language'
  ];

  async function handleSubmit() {
    if (!name.trim() || !promptTemplate.trim()) {
      showToast('Name and template content are required', 'error');
      return;
    }

    saving = true;
    try {
      const url = mode === 'edit' && template
        ? `/api/templates/${template.id}`
        : '/api/templates';

      const method = mode === 'edit' ? 'PATCH' : 'POST';

      const res = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: name.trim(),
          docType,
          promptTemplate: promptTemplate.trim(),
          isDefault
        })
      });

      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.message || 'Failed to save');
      }

      const { template: saved } = await res.json();
      showToast(`Template ${mode === 'edit' ? 'updated' : 'created'}!`, 'success');
      dispatch('save', saved);
    } catch (err) {
      showToast(err instanceof Error ? err.message : 'Failed to save template', 'error');
    } finally {
      saving = false;
    }
  }

  function loadDefault() {
    const defaults: Record<string, string> = {
      readme: `Generate a comprehensive README.md...`,
      api: `Generate API documentation...`,
      architecture: `Generate architecture documentation...`,
      setup: `Generate a setup guide...`
    };
    promptTemplate = defaults[docType] || '';
  }
</script>

<div class="space-y-6">
  <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
    <div>
      <label for="name" class="block text-sm font-medium text-text-secondary mb-2">
        Template Name
      </label>
      <input
        id="name"
        type="text"
        bind:value={name}
        placeholder="e.g., Standard README"
        class="input"
        disabled={saving}
      />
    </div>

    <div>
      <label for="docType" class="block text-sm font-medium text-text-secondary mb-2">
        Document Type
      </label>
      <select
        id="docType"
        bind:value={docType}
        class="select"
        disabled={mode === 'edit' || saving}
      >
        {#each docTypes as type}
          <option value={type.value}>{type.label}</option>
        {/each}
      </select>
    </div>
  </div>

  <div>
    <div class="flex justify-between items-center mb-2">
      <label for="prompt" class="block text-sm font-medium text-text-secondary">
        Prompt Template
      </label>
      <button
        type="button"
        on:click={loadDefault}
        class="text-sm text-accent hover:underline"
      >
        Load Default
      </button>
    </div>
    <textarea
      id="prompt"
      bind:value={promptTemplate}
      rows="12"
      placeholder="Enter the prompt template that will be sent to Claude..."
      class="input font-mono text-sm resize-y"
      disabled={saving}
    ></textarea>
  </div>

  <!-- Variables Reference -->
  <div class="p-4 bg-dark-700 rounded-lg">
    <p class="text-sm font-medium text-text-secondary mb-2">Available Variables</p>
    <div class="grid grid-cols-1 md:grid-cols-2 gap-1 text-sm text-text-muted font-mono">
      {#each variables as v}
        <span>{v}</span>
      {/each}
    </div>
  </div>

  <div class="flex items-center gap-4">
    <label class="flex items-center gap-2 cursor-pointer">
      <input
        type="checkbox"
        bind:checked={isDefault}
        class="checkbox"
        disabled={saving}
      />
      <span class="text-text-secondary">Set as default for {docTypes.find(d => d.value === docType)?.label}</span>
    </label>
  </div>

  <div class="flex gap-3">
    <button
      type="button"
      on:click={handleSubmit}
      class="btn-primary"
      disabled={saving || !name.trim() || !promptTemplate.trim()}
    >
      {saving ? 'Saving...' : mode === 'edit' ? 'Update Template' : 'Create Template'}
    </button>
    <button
      type="button"
      on:click={() => dispatch('cancel')}
      class="btn-secondary"
      disabled={saving}
    >
      Cancel
    </button>
  </div>
</div>
```

### 5. Create Templates Management Page

**File:** `src/routes/dashboard/templates/+page.svelte`

```svelte
<script lang="ts">
  import { onMount } from 'svelte';
  import Header from '$lib/components/Header.svelte';
  import TemplateEditor from '$lib/components/TemplateEditor.svelte';
  import type { DocTemplate } from '$lib/types';
  import { showToast } from '$lib/stores/toast';

  export let data;

  let templates: DocTemplate[] = [];
  let loading = true;
  let showEditor = false;
  let editingTemplate: DocTemplate | null = null;

  const docTypeLabels: Record<string, string> = {
    readme: 'README',
    api: 'API Docs',
    architecture: 'Architecture',
    setup: 'Setup Guide'
  };

  onMount(async () => {
    try {
      const res = await fetch('/api/templates');
      if (res.ok) {
        const data = await res.json();
        templates = data.templates;
      }
    } catch (err) {
      showToast('Failed to load templates', 'error');
    } finally {
      loading = false;
    }
  });

  function openCreate() {
    editingTemplate = null;
    showEditor = true;
  }

  function openEdit(template: DocTemplate) {
    editingTemplate = template;
    showEditor = true;
  }

  function handleSave(e: CustomEvent<DocTemplate>) {
    const saved = e.detail;
    if (editingTemplate) {
      templates = templates.map(t => t.id === saved.id ? saved : t);
    } else {
      templates = [...templates, saved];
    }
    showEditor = false;
  }

  async function handleDelete(id: string) {
    if (!confirm('Delete this template?')) return;

    try {
      const res = await fetch(`/api/templates/${id}`, { method: 'DELETE' });
      if (!res.ok) throw new Error('Failed to delete');

      templates = templates.filter(t => t.id !== id);
      showToast('Template deleted', 'success');
    } catch (err) {
      showToast('Failed to delete template', 'error');
    }
  }

  async function handleDuplicate(template: DocTemplate) {
    const name = prompt('Enter name for the copy:', `${template.name} (Copy)`);
    if (!name) return;

    try {
      const res = await fetch(`/api/templates/${template.id}/duplicate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name })
      });

      if (!res.ok) throw new Error('Failed to duplicate');

      const { template: copied } = await res.json();
      templates = [...templates, copied];
      showToast('Template duplicated', 'success');
    } catch (err) {
      showToast('Failed to duplicate template', 'error');
    }
  }

  // Group templates by type
  $: groupedTemplates = templates.reduce((acc, t) => {
    if (!acc[t.doc_type]) acc[t.doc_type] = [];
    acc[t.doc_type].push(t);
    return acc;
  }, {} as Record<string, DocTemplate[]>);
</script>

<svelte:head>
  <title>Documentation Templates - Codec8</title>
</svelte:head>

<Header />

<main class="min-h-screen bg-dark-900 pt-20">
  <div class="container mx-auto px-4 py-8">
    <div class="flex items-center justify-between mb-8">
      <div>
        <h1 class="text-3xl font-bold text-white">Documentation Templates</h1>
        <p class="text-text-secondary mt-1">Customize how your documentation is generated</p>
      </div>
      <div class="flex gap-3">
        <a href="/dashboard" class="btn-secondary">Back to Dashboard</a>
        <button on:click={openCreate} class="btn-primary">
          Create Template
        </button>
      </div>
    </div>

    {#if showEditor}
      <div class="card p-6 mb-8">
        <h2 class="text-xl font-bold text-white mb-6">
          {editingTemplate ? 'Edit Template' : 'Create Template'}
        </h2>
        <TemplateEditor
          template={editingTemplate}
          mode={editingTemplate ? 'edit' : 'create'}
          on:save={handleSave}
          on:cancel={() => showEditor = false}
        />
      </div>
    {/if}

    {#if loading}
      <div class="space-y-4">
        {#each Array(3) as _}
          <div class="card p-4">
            <div class="skeleton h-6 w-48 mb-2"></div>
            <div class="skeleton h-4 w-96"></div>
          </div>
        {/each}
      </div>
    {:else if templates.length === 0}
      <div class="card p-12 text-center">
        <div class="w-16 h-16 bg-dark-600 rounded-full flex items-center justify-center mx-auto mb-4">
          <svg class="w-8 h-8 text-text-muted" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
              d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
          </svg>
        </div>
        <h3 class="text-lg font-medium text-white mb-2">No custom templates yet</h3>
        <p class="text-text-secondary mb-6">
          Create templates to customize how documentation is generated for your team.
        </p>
        <button on:click={openCreate} class="btn-primary">
          Create Your First Template
        </button>
      </div>
    {:else}
      <div class="space-y-8">
        {#each Object.entries(groupedTemplates) as [docType, typeTemplates]}
          <div>
            <h2 class="text-lg font-semibold text-white mb-4">
              {docTypeLabels[docType] || docType}
            </h2>
            <div class="grid gap-4">
              {#each typeTemplates as template}
                <div class="card p-4 flex items-center justify-between">
                  <div>
                    <div class="flex items-center gap-2">
                      <span class="text-white font-medium">{template.name}</span>
                      {#if template.is_default}
                        <span class="badge-accent text-xs">Default</span>
                      {/if}
                    </div>
                    <p class="text-text-muted text-sm mt-1 line-clamp-1">
                      {template.prompt_template.substring(0, 100)}...
                    </p>
                  </div>
                  <div class="flex items-center gap-2">
                    <button
                      on:click={() => handleDuplicate(template)}
                      class="p-2 text-text-muted hover:text-white"
                      title="Duplicate"
                    >
                      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                          d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                      </svg>
                    </button>
                    <button
                      on:click={() => openEdit(template)}
                      class="p-2 text-text-muted hover:text-accent"
                      title="Edit"
                    >
                      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                          d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                      </svg>
                    </button>
                    <button
                      on:click={() => handleDelete(template.id)}
                      class="p-2 text-text-muted hover:text-error"
                      title="Delete"
                    >
                      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                          d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                      </svg>
                    </button>
                  </div>
                </div>
              {/each}
            </div>
          </div>
        {/each}
      </div>
    {/if}
  </div>
</main>
```

**File:** `src/routes/dashboard/templates/+page.server.ts`

```typescript
import { redirect } from '@sveltejs/kit';
import type { PageServerLoad } from './$types';

export const load: PageServerLoad = async ({ locals }) => {
  if (!locals.user) {
    throw redirect(303, '/auth/login');
  }

  // Team tier required for templates
  if (locals.profile?.subscription_tier !== 'team') {
    throw redirect(303, '/dashboard?upgrade=templates');
  }

  if (!locals.profile?.default_team_id) {
    throw redirect(303, '/dashboard?error=no_team');
  }

  return {
    profile: locals.profile
  };
};
```

## Verification

- [ ] Templates can be created with all doc types
- [ ] Default templates are applied in generation
- [ ] Only one default per doc type per team
- [ ] Template editor validates required fields
- [ ] Templates can be edited and deleted
- [ ] Duplicate creates independent copy
- [ ] Non-Team users cannot access templates
- [ ] Template variables are documented

## Testing Scenarios

1. Create template → verify saved correctly
2. Set as default → verify previous default unset
3. Generate docs → verify custom template used
4. Edit template → verify changes persisted
5. Delete template → verify removed
6. Duplicate → verify creates new copy
7. Pro user access → verify redirected

## Notes

- Template variables can be expanded in future ({{language}}, {{dependencies}})
- Consider adding template preview functionality
- Consider template sharing between teams (marketplace)
- Rate limit template operations to prevent abuse
