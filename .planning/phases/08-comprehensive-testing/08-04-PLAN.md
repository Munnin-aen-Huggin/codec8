---
phase: 08-comprehensive-testing
plan: 04
type: tdd
domain: testing
---

<objective>
Unit tests for rate limiting utilities with mocked Supabase.

Purpose: Test rate limiting logic without actual database calls using vitest mocking.
Output: Complete test coverage for ratelimit.ts pure functions and mocked DB functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@src/lib/server/ratelimit.ts
@src/lib/server/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rate Limiting Pure Function Tests</name>
  <files>src/lib/server/ratelimit.test.ts</files>
  <action>
Create tests for pure functions in ratelimit.ts:

**hashIP tests:**
- Returns consistent hash for same IP
- Returns different hashes for different IPs
- Returns 64-character hex string (SHA256)
- Handles IPv4 addresses
- Handles IPv6 addresses

**hashFingerprint tests:**
- Returns consistent hash for same fingerprint
- Returns 64-character hex string
- Different fingerprints produce different hashes

These are pure functions using Node crypto - no mocking needed.
  </action>
  <verify>npm run test:unit -- src/lib/server/ratelimit.test.ts passes</verify>
  <done>10+ tests for hashing functions</done>
</task>

<task type="auto">
  <name>Task 2: Rate Limiting DB Function Tests with Mocks</name>
  <files>src/lib/server/ratelimit.test.ts (append to existing)</files>
  <action>
Add tests for DB-dependent functions using vitest mocking:

**Setup mocking:**
```typescript
vi.mock('./supabase', () => ({
  supabaseAdmin: {
    from: vi.fn().mockReturnThis(),
    select: vi.fn().mockReturnThis(),
    eq: vi.fn().mockReturnThis(),
    or: vi.fn().mockReturnThis(),
    limit: vi.fn().mockReturnThis(),
    single: vi.fn(),
    upsert: vi.fn(),
    insert: vi.fn(),
    update: vi.fn()
  }
}));
```

**isBlocked tests:**
- Returns true when IP is in blocked_clients
- Returns true when fingerprint is blocked
- Returns false when neither blocked
- Handles database errors gracefully

**checkDemoLimit tests:**
- Returns { allowed: true, remaining: 1 } for new IP
- Returns { allowed: false, remaining: 0 } when limit reached
- Handles PGRST116 error (no rows) as allowed

**incrementDemoUsage tests:**
- Calls upsert with correct data
- Handles upsert errors by trying update
- Logs errors but doesn't throw

Note: Focus on testing the logic, not the actual DB operations.
  </action>
  <verify>npm run test:unit -- src/lib/server/ratelimit.test.ts passes with all tests</verify>
  <done>15+ tests covering all ratelimit functions</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All tests pass
- [ ] Mocking works correctly (no actual DB calls)
- [ ] No TypeScript errors
</verification>

<success_criteria>
- All tasks completed
- 25+ tests for rate limiting module
- Both pure functions and mocked DB functions tested
- Tests are fast (no network calls)
</success_criteria>

<output>
After completion, create `.planning/phases/08-comprehensive-testing/08-04-SUMMARY.md`
</output>
