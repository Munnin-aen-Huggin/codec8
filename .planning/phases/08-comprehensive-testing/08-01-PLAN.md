---
phase: 08-comprehensive-testing
plan: 01
type: tdd
domain: testing
---

<objective>
Unit tests for pure utility functions: bot detection and code parser utilities.

Purpose: Test pure functions with clear inputs/outputs using TDD approach. These are ideal TDD candidates - no external dependencies, deterministic behavior.
Output: Complete test coverage for botdetect.ts and parser.ts utility functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/lib/server/botdetect.ts
@src/lib/utils/parser.ts
@src/lib/stores/toast.test.ts (existing test pattern)
@vite.config.ts (test configuration)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bot Detection Unit Tests</name>
  <files>src/lib/server/botdetect.test.ts</files>
  <action>
Create comprehensive tests for botdetect.ts:

**isSuspiciousUA tests:**
- Returns true for null/empty user agents
- Returns true for known bot patterns (curl, wget, python-requests, scrapy, puppeteer, playwright, selenium, axios, postman)
- Returns false for legitimate browser user agents (Chrome, Firefox, Safari, Edge)
- Case insensitivity verification

**getClientIP tests:**
- Extracts first IP from x-forwarded-for with multiple IPs
- Falls back to x-real-ip when no x-forwarded-for
- Falls back to cf-connecting-ip
- Falls back to true-client-ip
- Returns '0.0.0.0' when no headers present
- Trims whitespace from IPs

Use mock Request objects with custom headers.
  </action>
  <verify>npm run test:unit -- src/lib/server/botdetect.test.ts passes with all tests green</verify>
  <done>15+ test cases covering all bot detection scenarios</done>
</task>

<task type="auto">
  <name>Task 2: Parser Utility Unit Tests</name>
  <files>src/lib/utils/parser.test.ts</files>
  <action>
Create comprehensive tests for pure functions in parser.ts:

**detectFramework tests:**
- Returns null for null packageJson
- Returns 'SvelteKit' when @sveltejs/kit present
- Returns 'Next.js' when next present
- Returns 'React' when only react present (not Next)
- Returns 'Express' for express backend
- Returns null when no known framework detected
- Tests specificity order (SvelteKit over Svelte, Next.js over React)

**identifyKeyFiles tests:**
- Identifies package.json in root
- Identifies tsconfig.json
- Identifies various config files (vite.config.ts, svelte.config.js)
- Identifies .env.example
- Ignores non-blob types (tree items)
- Returns empty array for empty tree

**identifyRouteFiles tests:**
- Identifies SvelteKit +server.ts routes
- Identifies Next.js pages/api routes
- Identifies app/api routes
- Ignores non-matching files
- Returns empty array for empty tree

**buildFileTree tests:**
- Builds correct tree structure with indentation
- Respects maxDepth parameter
- Skips node_modules, .git, dist directories
- Skips hidden files except .env and .github
- Handles empty tree gracefully
- Sorts paths alphabetically
  </action>
  <verify>npm run test:unit -- src/lib/utils/parser.test.ts passes</verify>
  <done>20+ test cases covering all parser utility functions</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run test:unit` passes all new tests
- [ ] No TypeScript errors (`npm run check`)
- [ ] Test files follow existing patterns (describe/it/expect)
- [ ] Coverage includes edge cases and error conditions
</verification>

<success_criteria>
- All tasks completed
- 35+ new unit tests passing
- Bot detection fully tested
- Parser utilities fully tested
- Tests run in under 5 seconds
</success_criteria>

<output>
After completion, create `.planning/phases/08-comprehensive-testing/08-01-SUMMARY.md`
</output>
