---
phase: 07-saas-transformation
plan: 04
type: execute
---

<objective>
Restructure Stripe integration for hybrid pricing: one-time purchases ($39) plus monthly subscriptions ($99/$249).

Purpose: Enable the new pricing model with both one-time and recurring payment options.
Output: Updated Stripe module and webhook handler supporting hybrid pricing.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/codebase/INTEGRATIONS.md
@src/lib/server/stripe.ts
@src/routes/api/stripe/checkout/+server.ts
@src/routes/api/stripe/webhook/+server.ts

**Tech stack available:** Stripe SDK 20.1.2
**Established patterns:** stripe.checkout.sessions.create, webhook signature verification
**New pricing model:**
- Single Repo: $39 one-time (STRIPE_PRICE_SINGLE)
- Pro: $99/mo subscription with 7-day trial (STRIPE_PRICE_PRO)
- Team: $249/mo subscription with 7-day trial (STRIPE_PRICE_TEAM)
- Regenerate: $9 one-time (dynamically created)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Stripe module for hybrid pricing</name>
  <files>src/lib/server/stripe.ts</files>
  <action>
Replace current one-time-only pricing with hybrid model:

```typescript
import Stripe from 'stripe';
import { STRIPE_SECRET_KEY } from '$env/static/private';
import {
  STRIPE_PRICE_SINGLE,
  STRIPE_PRICE_PRO,
  STRIPE_PRICE_TEAM
} from '$env/static/private';

export const stripe = new Stripe(STRIPE_SECRET_KEY, {
  apiVersion: '2025-12-15.clover'
});

// Product types
export type ProductType = 'single' | 'pro' | 'team';
type PurchaseMode = 'payment' | 'subscription';

interface ProductConfig {
  priceId: string;
  mode: PurchaseMode;
  trialDays?: number;
}

const PRODUCTS: Record<ProductType, ProductConfig> = {
  single: {
    priceId: STRIPE_PRICE_SINGLE || 'price_single_placeholder',
    mode: 'payment'
  },
  pro: {
    priceId: STRIPE_PRICE_PRO || 'price_pro_placeholder',
    mode: 'subscription',
    trialDays: 7
  },
  team: {
    priceId: STRIPE_PRICE_TEAM || 'price_team_placeholder',
    mode: 'subscription',
    trialDays: 7
  }
};

// Plan limits for subscription tiers
export const PLAN_LIMITS = {
  free: { repos: 1, docsPerMonth: 3 },
  single: { repos: 1, docsPerMonth: -1 }, // 1 specific repo, unlimited regenerations with payment
  pro: { reposPerMonth: 30 },
  team: { reposPerMonth: 100, seats: 5 }
} as const;

export async function createCheckoutSession({
  userId,
  userEmail,
  product,
  repoUrl,
  successUrl,
  cancelUrl
}: {
  userId: string;
  userEmail: string;
  product: ProductType;
  repoUrl?: string; // For single repo purchase
  successUrl: string;
  cancelUrl: string;
}): Promise<string> {
  const config = PRODUCTS[product];

  if (!config.priceId || config.priceId.includes('placeholder')) {
    throw new Error(`Price ID not configured for product: ${product}`);
  }

  const sessionParams: Stripe.Checkout.SessionCreateParams = {
    mode: config.mode,
    payment_method_types: ['card'],
    customer_email: userEmail,
    line_items: [{ price: config.priceId, quantity: 1 }],
    metadata: {
      userId,
      product,
      repoUrl: repoUrl || ''
    },
    success_url: successUrl,
    cancel_url: cancelUrl
  };

  // Add trial for subscriptions
  if (config.mode === 'subscription' && config.trialDays) {
    sessionParams.subscription_data = {
      trial_period_days: config.trialDays
    };
  }

  const session = await stripe.checkout.sessions.create(sessionParams);
  return session.url || '';
}

export async function createRegenerateCheckout({
  userId,
  repoId,
  successUrl,
  cancelUrl
}: {
  userId: string;
  repoId: string;
  successUrl: string;
  cancelUrl: string;
}): Promise<string> {
  // $9 one-time for regenerating a single-repo purchase
  const session = await stripe.checkout.sessions.create({
    mode: 'payment',
    payment_method_types: ['card'],
    line_items: [{
      price_data: {
        currency: 'usd',
        unit_amount: 900, // $9 in cents
        product_data: { name: 'Regenerate Documentation' }
      },
      quantity: 1
    }],
    metadata: {
      userId,
      repoId,
      type: 'regenerate'
    },
    success_url: successUrl,
    cancel_url: cancelUrl
  });

  return session.url || '';
}

// Keep existing utilities
export function constructWebhookEvent(
  payload: string,
  signature: string,
  webhookSecret: string
): Stripe.Event {
  return stripe.webhooks.constructEvent(payload, signature, webhookSecret);
}

// Price display info (updated for new model)
export const PRICE_DETAILS = {
  single: {
    name: 'Single Repo',
    price: 39,
    type: 'one-time',
    description: 'Full documentation suite for one repository',
    features: [
      'All 4 documentation types',
      'Private repo support',
      'Export & create PRs',
      'Keep forever',
      'Regenerate: $9'
    ]
  },
  pro: {
    name: 'Pro',
    price: 99,
    type: 'monthly',
    description: '30 repos per month with all features',
    features: [
      '30 repos per month',
      'All 4 documentation types',
      'Private repo support',
      'Auto-sync on push',
      'Priority support',
      '7-day free trial'
    ]
  },
  team: {
    name: 'Team',
    price: 249,
    type: 'monthly',
    description: '100 repos per month with team features',
    features: [
      '100 repos per month',
      '5 team members',
      'Everything in Pro',
      'Custom templates',
      'Slack integration',
      '7-day free trial'
    ]
  }
} as const;
```

Remove old LTD/DFY pricing references. Update env var imports to use new names.
  </action>
  <verify>TypeScript compiles: `npm run check`</verify>
  <done>stripe.ts supports hybrid pricing with one-time and subscription modes</done>
</task>

<task type="auto">
  <name>Task 2: Update webhook handler for hybrid events</name>
  <files>src/routes/api/stripe/webhook/+server.ts</files>
  <action>
Update webhook to handle both one-time payments and subscription events:

```typescript
// Handle checkout.session.completed
case 'checkout.session.completed': {
  const session = event.data.object as Stripe.Checkout.Session;
  const { userId, product, repoUrl, repoId, type } = session.metadata || {};

  if (type === 'regenerate') {
    // Handle regeneration purchase
    // Update purchased_repos.last_generated_at
    // Trigger doc regeneration
    break;
  }

  if (product === 'single') {
    // One-time single repo purchase
    // Insert into purchased_repos table
    // Set up for doc generation
    await supabaseAdmin.from('purchased_repos').insert({
      user_id: userId,
      repo_url: repoUrl,
      repo_name: extractRepoName(repoUrl),
      stripe_payment_id: session.payment_intent as string
    });
    break;
  }

  if (product === 'pro' || product === 'team') {
    // Subscription started (may be trialing)
    const subscription = await stripe.subscriptions.retrieve(
      session.subscription as string
    );
    await supabaseAdmin.from('profiles').update({
      stripe_customer_id: session.customer as string,
      stripe_subscription_id: session.subscription as string,
      subscription_status: subscription.status, // 'trialing' or 'active'
      subscription_tier: product,
      trial_ends_at: subscription.trial_end
        ? new Date(subscription.trial_end * 1000).toISOString()
        : null
    }).eq('id', userId);
    break;
  }
  break;
}

// Handle subscription updates
case 'customer.subscription.updated': {
  const subscription = event.data.object as Stripe.Subscription;
  const customerId = subscription.customer as string;

  // Find user by customer ID
  const { data: profile } = await supabaseAdmin
    .from('profiles')
    .select('id')
    .eq('stripe_customer_id', customerId)
    .single();

  if (profile) {
    await supabaseAdmin.from('profiles').update({
      subscription_status: subscription.status,
      // Reset usage on new billing period
      ...(subscription.status === 'active' && {
        repos_used_this_month: 0,
        repos_reset_at: new Date().toISOString()
      })
    }).eq('id', profile.id);
  }
  break;
}

// Handle subscription cancellation
case 'customer.subscription.deleted': {
  const subscription = event.data.object as Stripe.Subscription;
  const customerId = subscription.customer as string;

  const { data: profile } = await supabaseAdmin
    .from('profiles')
    .select('id')
    .eq('stripe_customer_id', customerId)
    .single();

  if (profile) {
    await supabaseAdmin.from('profiles').update({
      subscription_status: 'canceled',
      subscription_ends_at: new Date().toISOString()
    }).eq('id', profile.id);
  }
  break;
}
```

Add helper function:
```typescript
function extractRepoName(url: string): string {
  const match = url.match(/github\.com\/([^\/]+\/[^\/]+)/);
  return match ? match[1] : url;
}
```
  </action>
  <verify>Webhook handles test events correctly (use Stripe CLI: `stripe trigger checkout.session.completed`)</verify>
  <done>Webhook handles one-time payments, subscription creation, updates, and cancellation</done>
</task>

<task type="auto">
  <name>Task 3: Update checkout endpoint for new products</name>
  <files>src/routes/api/stripe/checkout/+server.ts</files>
  <action>
Update checkout endpoint to use new product types and handle intent params:

```typescript
import { json, error, redirect } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { createCheckoutSession, createRegenerateCheckout } from '$lib/server/stripe';
import { supabaseAdmin } from '$lib/server/supabase';
import { PUBLIC_APP_URL } from '$env/static/public';

export const POST: RequestHandler = async ({ request, cookies }) => {
  // Get session
  const sessionCookie = cookies.get('session');
  if (!sessionCookie) {
    throw error(401, 'Authentication required');
  }

  const session = JSON.parse(sessionCookie);
  const userId = session.userId;

  // Get user email
  const { data: profile } = await supabaseAdmin
    .from('profiles')
    .select('email')
    .eq('id', userId)
    .single();

  if (!profile) {
    throw error(404, 'User not found');
  }

  const body = await request.json();
  const { product, repoUrl, repoId } = body;

  // Handle regeneration separately
  if (body.type === 'regenerate' && repoId) {
    const url = await createRegenerateCheckout({
      userId,
      repoId,
      successUrl: `${PUBLIC_APP_URL}/dashboard/${repoId}?regenerated=true`,
      cancelUrl: `${PUBLIC_APP_URL}/dashboard/${repoId}`
    });
    return json({ url });
  }

  // Validate product type
  if (!['single', 'pro', 'team'].includes(product)) {
    throw error(400, 'Invalid product type');
  }

  // For single repo, require repoUrl
  if (product === 'single' && !repoUrl) {
    throw error(400, 'Repository URL required for single repo purchase');
  }

  const url = await createCheckoutSession({
    userId,
    userEmail: profile.email,
    product,
    repoUrl,
    successUrl: `${PUBLIC_APP_URL}/checkout/success?session_id={CHECKOUT_SESSION_ID}`,
    cancelUrl: `${PUBLIC_APP_URL}/pricing`
  });

  return json({ url });
};
```
  </action>
  <verify>Checkout endpoint accepts new product types: `npm run check`</verify>
  <done>Checkout endpoint supports single, pro, team products and regeneration</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run check` passes
- [ ] `npm run build` succeeds
- [ ] stripe.ts exports new functions correctly
- [ ] Webhook handles all event types
- [ ] No references to old LTD/DFY pricing
</verification>

<success_criteria>
- Hybrid pricing model fully implemented
- One-time purchases work (single repo)
- Subscription checkouts include 7-day trial
- Webhook handles all relevant events
- Regeneration checkout works
- Old pricing removed
</success_criteria>

<output>
After completion, create `.planning/phases/07-saas-transformation/07-04-SUMMARY.md`
</output>
